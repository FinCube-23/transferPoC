# Requirements Document

## Introduction

This document specifies the requirements for a Zero-Knowledge Proof (ZKP) Controller system that generates cryptographic proofs using a Noir circuit backend and verifies them against an on-chain Honk verifier smart contract. The system enables privacy-preserving verification of B2B membership credentials through ZKP technology, allowing users to prove membership without revealing sensitive information.

## Glossary

-   **ZKP Controller**: The backend service responsible for orchestrating proof generation and verification
-   **Noir Circuit**: A zero-knowledge proof circuit written in the Noir language that defines the computation to be proven
-   **Prover Backend**: The local backend system that compiles circuits and generates proofs using Nargo and Barretenberg (bb) tools
-   **Honk Verifier**: A smart contract deployed on-chain that verifies ZKP proofs using the Honk proving system
-   **Witness**: The private inputs to the circuit that are used to generate the proof
-   **Public Inputs**: The public values that are part of the proof statement
-   **Proof Artifact**: The cryptographic proof data generated by the prover backend
-   **Verification Key**: The cryptographic key used by the verifier to validate proofs
-   **Alchemy Provider**: The Web3 service provider used to interact with the blockchain
-   **Test Data Generator**: A utility that creates valid test inputs for circuit testing

## Requirements

### Requirement 1

**User Story:** As a developer, I want to generate ZKP proofs from test data, so that I can verify the circuit works correctly before production use.

#### Acceptance Criteria

1. WHEN the ZKP Controller receives a proof generation request THEN the system SHALL navigate to the circuit directory and execute the proof generation workflow
2. WHEN generating test data THEN the system SHALL invoke the test data generator utility and validate successful execution
3. WHEN compiling the circuit THEN the system SHALL execute nargo compile and verify the compilation produces valid bytecode
4. WHEN generating the witness THEN the system SHALL execute nargo execute and validate the witness file is created successfully
5. WHEN generating the proof THEN the system SHALL execute the Barretenberg prover with the compiled circuit and witness to produce proof artifacts

### Requirement 2

**User Story:** As a developer, I want to verify generated proofs against the on-chain verifier, so that I can ensure end-to-end correctness of the ZKP system.

#### Acceptance Criteria

1. WHEN the ZKP Controller has generated proof artifacts THEN the system SHALL read the proof and public inputs from the target directory
2. WHEN submitting a verification request THEN the system SHALL connect to the Honk Verifier smart contract using the Alchemy provider
3. WHEN calling the verifier contract THEN the system SHALL invoke the verify function with the proof bytes and public inputs array
4. WHEN the verification completes THEN the system SHALL return the verification result as a boolean value
5. WHEN verification fails THEN the system SHALL provide detailed error information including transaction data and revert reasons

### Requirement 3

**User Story:** As a system operator, I want the proof generation process to handle errors gracefully, so that I can diagnose and fix issues quickly.

#### Acceptance Criteria

1. WHEN any step in the proof generation workflow fails THEN the system SHALL capture the error and halt further execution
2. WHEN test data generation fails THEN the system SHALL log the failure reason and return an error response
3. WHEN circuit compilation fails THEN the system SHALL log compilation errors and return diagnostic information
4. WHEN witness generation fails THEN the system SHALL log the Prover.toml contents for debugging and return an error response
5. WHEN proof generation fails THEN the system SHALL check for missing target files and report which artifacts are unavailable

### Requirement 4

**User Story:** As a developer, I want to execute the complete proof workflow through API endpoints, so that I can integrate ZKP functionality into applications.

#### Acceptance Criteria

1. WHEN the ZKP Controller starts THEN the system SHALL expose HTTP endpoints for proof generation and verification
2. WHEN a client calls the proof generation endpoint THEN the system SHALL execute the complete workflow and return proof artifacts
3. WHEN a client calls the verification endpoint with proof data THEN the system SHALL verify against the on-chain contract and return the result
4. WHEN processing requests THEN the system SHALL validate input parameters before executing operations
5. WHEN operations complete THEN the system SHALL return structured JSON responses with status and result data

### Requirement 5

**User Story:** As a developer, I want to interact with the Honk Verifier smart contract, so that I can verify proofs on-chain.

#### Acceptance Criteria

1. WHEN initializing the verifier client THEN the system SHALL load the contract ABI from the artifacts directory
2. WHEN connecting to the contract THEN the system SHALL use the contract address from the deployment configuration
3. WHEN sending transactions THEN the system SHALL sign them using the configured wallet private key
4. WHEN calling view functions THEN the system SHALL use the Alchemy provider to read contract state
5. WHEN contract calls fail THEN the system SHALL parse and return the specific error type from the contract

### Requirement 6

**User Story:** As a system administrator, I want the proof generation to follow the established circuit testing workflow, so that proofs are generated consistently and reliably.

#### Acceptance Criteria

1. WHEN executing the proof workflow THEN the system SHALL follow the sequence: test data generation, compilation, witness generation, proof generation, and verification
2. WHEN navigating directories THEN the system SHALL change to the base/circuit directory before executing Nargo commands
3. WHEN generating verification keys THEN the system SHALL use the Barretenberg tool with keccak oracle hash configuration
4. WHEN reading proof artifacts THEN the system SHALL locate files in the target directory with correct naming conventions
5. WHEN the workflow completes successfully THEN the system SHALL confirm all required artifacts exist: bytecode, witness, verification key, proof, and public inputs

### Requirement 7

**User Story:** As a developer, I want to parse and format proof data correctly, so that it can be submitted to the smart contract verifier.

#### Acceptance Criteria

1. WHEN reading proof files THEN the system SHALL parse the binary proof data into the correct format for contract submission
2. WHEN reading public inputs THEN the system SHALL parse them as an array of bytes32 values
3. WHEN formatting proof data THEN the system SHALL encode it as bytes type compatible with Solidity
4. WHEN preparing contract call parameters THEN the system SHALL match the verify function signature: verify(bytes proof, bytes32[] publicInputs)
5. WHEN encoding fails THEN the system SHALL return detailed error information about the data format issue

### Requirement 8

**User Story:** As a quality assurance engineer, I want comprehensive logging throughout the proof workflow, so that I can trace execution and debug issues.

#### Acceptance Criteria

1. WHEN each workflow step begins THEN the system SHALL log the step name and description
2. WHEN steps complete successfully THEN the system SHALL log success confirmation with relevant details
3. WHEN errors occur THEN the system SHALL log the error message, context, and any relevant file contents
4. WHEN listing directory contents THEN the system SHALL log file names and sizes for verification
5. WHEN the complete workflow finishes THEN the system SHALL log a summary of all steps with pass/fail status
